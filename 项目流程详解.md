# SVG Render é¡¹ç›®å®Œæ•´æµç¨‹è¯¦è§£

æœ¬æ–‡æ¡£è¯¦ç»†è®²è§£ä»å¯è§†åŒ–äº¤äº’çª—å£è®¾è®¡åˆ°æ–‡ä»¶è¯»å…¥ã€è§£æã€æ¸²æŸ“çš„å®Œæ•´æµç¨‹ã€‚

---

## ğŸ“‹ ç›®å½•

1. [æ•´ä½“æ¶æ„æ¦‚è§ˆ](#æ•´ä½“æ¶æ„æ¦‚è§ˆ)
2. [ç¬¬ä¸€é˜¶æ®µï¼šåº”ç”¨ç¨‹åºåˆå§‹åŒ–ä¸çª—å£åˆ›å»º](#ç¬¬ä¸€é˜¶æ®µåº”ç”¨ç¨‹åºåˆå§‹åŒ–ä¸çª—å£åˆ›å»º)
3. [ç¬¬äºŒé˜¶æ®µï¼šUIç•Œé¢è®¾è®¡ä¸äº¤äº’](#ç¬¬äºŒé˜¶æ®µuiç•Œé¢è®¾è®¡ä¸äº¤äº’)
4. [ç¬¬ä¸‰é˜¶æ®µï¼šSVGæ–‡ä»¶è¯»å–](#ç¬¬ä¸‰é˜¶æ®µsvgæ–‡ä»¶è¯»å–)
5. [ç¬¬å››é˜¶æ®µï¼šSVGæ–‡ä»¶è§£æ](#ç¬¬å››é˜¶æ®µsvgæ–‡ä»¶è§£æ)
6. [ç¬¬äº”é˜¶æ®µï¼šSVGæ¸²æŸ“](#ç¬¬äº”é˜¶æ®µsvgæ¸²æŸ“)
7. [å®Œæ•´æµç¨‹å›¾](#å®Œæ•´æµç¨‹å›¾)

---

## æ•´ä½“æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. ç¨‹åºå…¥å£ (main.cpp)                                      â”‚
â”‚     â””â”€> RunApp<Labs::SVG::App>                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. çª—å£åˆå§‹åŒ– (app.cpp)                                     â”‚
â”‚     â”œâ”€> GLFW çª—å£åˆ›å»º                                        â”‚
â”‚     â”œâ”€> OpenGL ä¸Šä¸‹æ–‡åˆå§‹åŒ– (GLAD)                           â”‚
â”‚     â””â”€> ImGui ç•Œé¢ç³»ç»Ÿåˆå§‹åŒ–                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. ä¸»å¾ªç¯ (App::OnFrame)                                    â”‚
â”‚     â””â”€> UI::Setup()                                          â”‚
â”‚         â””â”€> CaseSVGRender çš„æ–¹æ³•è°ƒç”¨                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚          â”‚          â”‚
        â–¼          â–¼          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ–‡ä»¶è¯»å– â”‚ â”‚ æ–‡ä»¶è§£æ â”‚ â”‚ æ¸²æŸ“æ˜¾ç¤º â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚           â”‚            â”‚
     â”‚           â”‚            â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  OpenGLçº¹ç†   â”‚
         â”‚  æ˜¾ç¤ºåˆ°çª—å£   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ç¬¬ä¸€é˜¶æ®µï¼šåº”ç”¨ç¨‹åºåˆå§‹åŒ–ä¸çª—å£åˆ›å»º

### 1.1 ç¨‹åºå…¥å£ç‚¹

**æ–‡ä»¶ï¼š** `src/VCX/Labs/svg/main.cpp`

```cpp
int main() {
    using namespace VCX;
    return Engine::RunApp<Labs::SVG::App>(Engine::AppContextOptions {
        .Title      = "SVG Render",
        .WindowSize = { 1024, 768 },
        .FontSize   = 16,
        .IconFileNames = Assets::DefaultIcons,
        .FontFileNames = Assets::DefaultFonts,
    });
}
```

**ä½œç”¨ï¼š**
- åˆ›å»ºåº”ç”¨ç¨‹åºå®ä¾‹ `Labs::SVG::App`
- ä¼ å…¥çª—å£é…ç½®å‚æ•°ï¼ˆæ ‡é¢˜ã€å¤§å°ã€å­—ä½“ç­‰ï¼‰
- å¯åŠ¨åº”ç”¨ç¨‹åºä¸»å¾ªç¯

### 1.2 çª—å£ç³»ç»Ÿåˆå§‹åŒ–

**æ–‡ä»¶ï¼š** `src/VCX/Engine/app.cpp`

#### æ­¥éª¤1ï¼šGLFWåˆå§‹åŒ– (`RunApp_InitGLFW`)

```cpp
// 1. è®¾ç½®é”™è¯¯å›è°ƒ
glfwSetErrorCallback(glfwErrorCallback);

// 2. åˆå§‹åŒ–GLFWåº“
glfwInit();

// 3. é…ç½®OpenGLç‰ˆæœ¬ï¼ˆ4.1 Core Profileï¼‰
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

// 4. åˆ›å»ºçª—å£ï¼ˆåˆå§‹ä¸å¯è§ï¼‰
g_glfwWindow = glfwCreateWindow(width, height, title, nullptr, nullptr);

// 5. è®¾ç½®çª—å£å›è°ƒå‡½æ•°
glfwSetWindowSizeCallback(...);      // çª—å£å¤§å°æ”¹å˜
glfwSetFramebufferSizeCallback(...); // å¸§ç¼“å†²å¤§å°æ”¹å˜

// 6. è®¾ç½®OpenGLä¸Šä¸‹æ–‡ä¸ºå½“å‰ä¸Šä¸‹æ–‡
glfwMakeContextCurrent(g_glfwWindow);
glfwSwapInterval(1);  // å‚ç›´åŒæ­¥
```

**å…³é”®ç‚¹ï¼š**
- GLFWè´Ÿè´£çª—å£ç®¡ç†å’Œè¾“å…¥å¤„ç†
- çª—å£åˆå§‹çŠ¶æ€ä¸ºä¸å¯è§ï¼ˆ`GLFW_VISIBLE = GLFW_FALSE`ï¼‰ï¼Œåˆå§‹åŒ–å®Œæˆåå†æ˜¾ç¤º

#### æ­¥éª¤2ï¼šGLADåˆå§‹åŒ– (`RunApp_InitGLAD`)

```cpp
if (gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)) {
    // æˆåŠŸåŠ è½½OpenGLå‡½æ•°æŒ‡é’ˆ
} else {
    // å¤±è´¥å¤„ç†
}
```

**ä½œç”¨ï¼š**
- GLADç”¨äºåŠ è½½OpenGLå‡½æ•°æŒ‡é’ˆ
- ä½¿ç¨‹åºèƒ½å¤Ÿè°ƒç”¨OpenGL API

#### æ­¥éª¤3ï¼šImGuiåˆå§‹åŒ– (`RunApp_InitImGui`)

```cpp
// 1. åˆ›å»ºImGuiä¸Šä¸‹æ–‡
ImGui::CreateContext();

// 2. åŠ è½½å­—ä½“
for (auto const & fontFileName : options.FontFileNames) {
    ImGui::GetIO().Fonts->AddFontFromFileTTF(fontFileName.data(), options.FontSize);
}

// 3. åˆå§‹åŒ–ImGuiçš„OpenGLå’ŒGLFWåç«¯
ImGui_ImplOpenGL3_Init();
ImGui_ImplGlfw_InitForOpenGL(g_glfwWindow, true);
```

**ä½œç”¨ï¼š**
- ImGuiæä¾›å³æ—¶æ¨¡å¼GUIç³»ç»Ÿ
- ç”¨äºåˆ›å»ºä¾§è¾¹æ ã€å·¥å…·æ ã€å±æ€§é¢æ¿ç­‰UIå…ƒç´ 

### 1.3 ä¸»å¾ªç¯å¯åŠ¨

**æ–‡ä»¶ï¼š** `src/VCX/Engine/app.cpp` - `RunApp_Main`

```cpp
void RunApp_Main(IApp && app) {
    RunApp_InitGLFWWindowCallbacks(app);
    glfwShowWindow(g_glfwWindow);  // æ˜¾ç¤ºçª—å£
    
    // ä¸»å¾ªç¯
    while (! glfwWindowShouldClose(g_glfwWindow)) {
        RunApp_Frame(app);  // æ¯å¸§è°ƒç”¨
        glfwPollEvents();    // å¤„ç†çª—å£äº‹ä»¶
    }
}
```

**æ¯å¸§æ‰§è¡Œæµç¨‹ (`RunApp_Frame`)ï¼š**

```cpp
static void RunApp_Frame(IApp & app) {
    // 1. è®¡ç®—å¸§ç‡å’Œæ—¶é—´å·®
    auto const currentTime = glfwGetTime();
    g_DeltaTime = currentTime - g_LastTime;
    
    // 2. è®¾ç½®OpenGLè§†å£
    glViewport(0, 0, g_FrameSize.first, g_FrameSize.second);
    glClearColor(0, 0, 0, 1);
    glClear(GL_COLOR_BUFFER_BIT);
    
    // 3. å¼€å§‹ImGuiæ–°å¸§
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();
    
    // 4. è°ƒç”¨åº”ç”¨ç¨‹åºçš„OnFrameæ–¹æ³•ï¼ˆæ ¸å¿ƒé€»è¾‘ï¼‰
    app.OnFrame();
    
    // 5. æ¸²æŸ“ImGui
    ImGui::Render();
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
    
    // 6. äº¤æ¢å‰åç¼“å†²åŒº
    glfwSwapBuffers(g_glfwWindow);
}
```

---

## ç¬¬äºŒé˜¶æ®µï¼šUIç•Œé¢è®¾è®¡ä¸äº¤äº’

### 2.1 åº”ç”¨ç¨‹åºç±»ç»“æ„

**æ–‡ä»¶ï¼š** `src/VCX/Labs/svg/App.h` å’Œ `App.cpp`

```cpp
class App : public VCX::Engine::IApp {
private:
    Common::UI _ui;              // UIç®¡ç†å™¨
    CaseSVGRender _caseSVGRender; // SVGæ¸²æŸ“æ¡ˆä¾‹
    
public:
    void OnFrame() override {
        _ui.Setup(_cases, _caseId);  // è®¾ç½®UIå¸ƒå±€
    }
};
```

### 2.2 UIå¸ƒå±€ç³»ç»Ÿ

**æ–‡ä»¶ï¼š** `src/VCX/Labs/Common/UI.h` å’Œ `UI.cpp`

UIç³»ç»Ÿé‡‡ç”¨**åŒçª—å£å¸ƒå±€**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¸»çª—å£ (Main Window)                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              â”‚  â”‚                         â”‚ â”‚
â”‚  â”‚  ä¾§è¾¹æ       â”‚  â”‚   æ¸²æŸ“åŒºåŸŸ               â”‚ â”‚
â”‚  â”‚  (Sidebar)   â”‚  â”‚   (Canvas)              â”‚ â”‚
â”‚  â”‚              â”‚  â”‚                         â”‚ â”‚
â”‚  â”‚  - ä»£ç ç¼–è¾‘  â”‚  â”‚   - SVGå›¾åƒæ˜¾ç¤º         â”‚ â”‚
â”‚  â”‚  - å±æ€§é¢æ¿  â”‚  â”‚   - äº¤äº’æ§åˆ¶ç‚¹          â”‚ â”‚
â”‚  â”‚  - å›¾å±‚åˆ—è¡¨  â”‚  â”‚   - å·¥å…·æ               â”‚ â”‚
â”‚  â”‚  - è®¾ç½®      â”‚  â”‚   - çŠ¶æ€æ               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**UI::Setup() åŠŸèƒ½ï¼š**
1. åˆ›å»ºä¾§è¾¹æ çª—å£ï¼ˆå¯æŠ˜å ï¼‰
2. åˆ›å»ºä¸»æ¸²æŸ“çª—å£
3. è°ƒç”¨ `CaseSVGRender::OnSetupPropsUI()` æ˜¾ç¤ºå±æ€§é¢æ¿
4. è°ƒç”¨ `CaseSVGRender::OnRender()` è·å–æ¸²æŸ“ç»“æœ
5. è°ƒç”¨ `CaseSVGRender::OnProcessInput()` å¤„ç†ç”¨æˆ·è¾“å…¥

### 2.3 CaseSVGRender çš„UIç»„ä»¶

**æ–‡ä»¶ï¼š** `src/VCX/Labs/svg/CaseSVGRender.cpp`

#### 2.3.1 å±æ€§é¢æ¿ (`OnSetupPropsUI`)

```cpp
void CaseSVGRender::OnSetupPropsUI() {
    if (ImGui::BeginTabBar("EditorTabs")) {
        // Tab 1: ä»£ç ç¼–è¾‘å™¨
        if (ImGui::BeginTabItem("Code")) {
            DrawCodeEditor();  // æ˜¾ç¤ºSVGæºä»£ç ç¼–è¾‘å™¨
            ImGui::EndTabItem();
        }
        
        // Tab 2: å±æ€§æ£€æŸ¥å™¨
        if (ImGui::BeginTabItem("Inspector")) {
            DrawPropertiesPanel();  // æ˜¾ç¤ºé€‰ä¸­å…ƒç´ çš„å±æ€§
            ImGui::EndTabItem();
        }
        
        // Tab 3: å›¾å±‚åˆ—è¡¨
        if (ImGui::BeginTabItem("Layers")) {
            DrawLayersPanel();  // æ˜¾ç¤ºæ‰€æœ‰å…ƒç´ åˆ—è¡¨
            ImGui::EndTabItem();
        }
        
        // Tab 4: è®¾ç½®
        if (ImGui::BeginTabItem("Settings")) {
            // æ–‡ä»¶æ“ä½œï¼šåŠ è½½ã€ä¿å­˜ã€æ¸…ç©º
            // ç¼–è¾‘å™¨è®¾ç½®ï¼šæ§åˆ¶ç‚¹æ˜¾ç¤ºã€ç½‘æ ¼ç­‰
            ImGui::EndTabItem();
        }
    }
}
```

#### 2.3.2 ä»£ç ç¼–è¾‘å™¨ (`DrawCodeEditor`)

```cpp
void CaseSVGRender::DrawCodeEditor() {
    // å¤šè¡Œæ–‡æœ¬è¾“å…¥æ¡†ï¼Œæ˜¾ç¤ºSVGæºä»£ç 
    if (ImGui::InputTextMultiline("##SVGEditor", _svgTextBuffer, 
                                 sizeof(_svgTextBuffer), ...)) {
        if (_autoSyncText) {
            UpdateSVGFromText();  // ä»æ–‡æœ¬æ›´æ–°SVGæ–‡æ¡£
            UpdateRender();       // é‡æ–°æ¸²æŸ“
        }
    }
}
```

**åŠŸèƒ½ï¼š**
- å®æ—¶ç¼–è¾‘SVGæºä»£ç 
- æ”¯æŒè‡ªåŠ¨åŒæ­¥æˆ–æ‰‹åŠ¨åº”ç”¨æ›´æ”¹
- æ–‡æœ¬ä¿®æ”¹åè‡ªåŠ¨è§¦å‘è§£æå’Œæ¸²æŸ“

#### 2.3.3 å±æ€§é¢æ¿ (`DrawPropertiesPanel`)

```cpp
void CaseSVGRender::DrawPropertiesPanel() {
    auto& element = _svgDocument.elements[_selectedElementIndex];
    
    // ç¼–è¾‘å…ƒç´ ID
    ImGui::InputText("ID", idBuf, ...);
    
    // ç¼–è¾‘å¡«å……é¢œè‰²
    ImGui::ColorEdit4("Fill Color", ...);
    
    // ç¼–è¾‘æè¾¹é¢œè‰²å’Œå®½åº¦
    ImGui::ColorEdit4("Stroke Color", ...);
    ImGui::DragFloat("Stroke Width", ...);
    
    // ç¼–è¾‘å˜æ¢çŸ©é˜µ
    ImGui::DragFloat3("Transform", ...);
    
    // åˆ é™¤å…ƒç´ 
    if (ImGui::Button("Delete Element")) {
        _svgDocument.elements.erase(...);
    }
}
```

#### 2.3.4 å·¥å…·æ å’ŒçŠ¶æ€æ 

```cpp
void CaseSVGRender::DrawToolbar() {
    // å·¥å…·æŒ‰é’®ï¼šé€‰æ‹©ã€å¹³ç§»ã€ç¼©æ”¾
    if (ImGui::Button("Select")) _currentTool = ToolType::Select;
    if (ImGui::Button("Pan")) _currentTool = ToolType::Pan;
    if (ImGui::Button("Zoom")) _currentTool = ToolType::Zoom;
}

void CaseSVGRender::DrawStatusBar(const ImVec2& mousePos) {
    // æ˜¾ç¤ºé¼ æ ‡ä½ç½®ã€ç¼©æ”¾çº§åˆ«ã€é€‰ä¸­å…ƒç´ ä¿¡æ¯ç­‰
    ImGui::Text("Mouse: (%.1f, %.1f)", mousePos.x, mousePos.y);
    ImGui::Text("Zoom: %.2fx", _zoomLevel);
}
```

---

## ç¬¬ä¸‰é˜¶æ®µï¼šSVGæ–‡ä»¶è¯»å–

### 3.1 æ–‡ä»¶è¯»å–å…¥å£

**æ–‡ä»¶ï¼š** `src/VCX/Labs/svg/CaseSVGRender.cpp` - `LoadSVGFile()`

```cpp
void CaseSVGRender::LoadSVGFile() {
    // æ­¥éª¤1ï¼šè¯»å–æ–‡ä»¶å†…å®¹åˆ°å­—ç¬¦ä¸²
    std::ifstream file(_svgFilePath);
    if (file.is_open()) {
        std::stringstream buffer;
        buffer << file.rdbuf();
        _svgTextContent = buffer.str();  // ä¿å­˜åŸå§‹æ–‡æœ¬
        file.close();
    }
    
    // æ­¥éª¤2ï¼šä½¿ç”¨è§£æå™¨è§£ææ–‡ä»¶
    if (_svgParser.ParseFile(_svgFilePath, _svgDocument)) {
        _fileLoaded = true;
        _recompute = true;  // æ ‡è®°éœ€è¦é‡æ–°æ¸²æŸ“
        
        // æ­¥éª¤3ï¼šæ›´æ–°æ–‡æœ¬ç¼–è¾‘å™¨å†…å®¹
        std::memcpy(_svgTextBuffer, _svgTextContent.data(), ...);
        
        // æ­¥éª¤4ï¼šæ›´æ–°å…ƒç´ è¾¹ç•Œæ¡†ï¼ˆç”¨äºäº¤äº’ï¼‰
        UpdateElementBounds();
    } else {
        // åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å†…ç½®æµ‹è¯•SVG
        _svgTextContent = testSVG;
        _svgParser.ParseString(testSVG, _svgDocument);
    }
}
```

**è§¦å‘æ—¶æœºï¼š**
- ç”¨æˆ·åœ¨Settingsæ ‡ç­¾é¡µç‚¹å‡»"Load File"æŒ‰é’®
- ç¨‹åºå¯åŠ¨æ—¶è‡ªåŠ¨åŠ è½½é»˜è®¤æ–‡ä»¶ï¼ˆ`assets/test_bezier.svg`ï¼‰

### 3.2 æ–‡ä»¶è·¯å¾„ç®¡ç†

```cpp
// é»˜è®¤æ–‡ä»¶è·¯å¾„
std::string _svgFilePath = "assets/test_bezier.svg";

// ç”¨æˆ·å¯ä»¥åœ¨UIä¸­ä¿®æ”¹è·¯å¾„
ImGui::InputText("SVG Path", pathBuf, ...);
if (ImGui::Button("Load File")) {
    _svgFilePath = pathBuf;
    LoadSVGFile();
}
```

---

## ç¬¬å››é˜¶æ®µï¼šSVGæ–‡ä»¶è§£æ

### 4.1 è§£æå™¨æ¶æ„

**æ–‡ä»¶ï¼š** `src/VCX/Labs/svg/SVGParser.h` å’Œ `SVGParser.cpp`

**æ ¸å¿ƒç±»ï¼š** `SVGParser`

**ä¾èµ–åº“ï¼š** `tinyxml2`ï¼ˆXMLè§£æåº“ï¼‰

### 4.2 è§£ææµç¨‹

#### æ­¥éª¤1ï¼šXMLæ–‡æ¡£åŠ è½½

```cpp
bool SVGParser::ParseFile(const std::string& filename, SVGDocument& document) {
    // ä½¿ç”¨tinyxml2åŠ è½½XMLæ–‡ä»¶
    tinyxml2::XMLError error = _xmlDoc->LoadFile(filename.c_str());
    if (error != tinyxml2::XML_SUCCESS) {
        return false;
    }
    
    // æŸ¥æ‰¾SVGæ ¹å…ƒç´ 
    tinyxml2::XMLElement* svgElement = _xmlDoc->FirstChildElement("svg");
    if (!svgElement) {
        return false;
    }
    
    // è§£æSVGæ ¹å…ƒç´ 
    return ParseSVGElement(svgElement, document);
}
```

#### æ­¥éª¤2ï¼šè§£æSVGæ ¹å…ƒç´ 

```cpp
bool SVGParser::ParseSVGElement(tinyxml2::XMLElement* svgElement, 
                                 SVGDocument& document) {
    // 1. è§£æSVGæ–‡æ¡£å±æ€§
    document.width = ParseLength(GetAttribute(svgElement, "width", "800"), 800.0f);
    document.height = ParseLength(GetAttribute(svgElement, "height", "600"), 600.0f);
    document.viewBox = GetAttribute(svgElement, "viewBox");
    
    // 2. éå†æ‰€æœ‰å­å…ƒç´ 
    for (tinyxml2::XMLElement* child = svgElement->FirstChildElement(); 
         child; 
         child = child->NextSiblingElement()) {
        
        std::string tagName = child->Name();
        
        // è·³è¿‡å…ƒæ•°æ®å…ƒç´ 
        if (tagName == "title" || tagName == "desc" || ...) {
            continue;
        }
        
        // 3. æ ¹æ®å…ƒç´ ç±»å‹è°ƒç”¨ç›¸åº”çš„è§£æå‡½æ•°
        SVGElement element;
        bool parsed = false;
        
        if (tagName == "path") {
            element.type = SVGElement::Type::Path;
            parsed = ParsePathElement(child, element);
        } else if (tagName == "circle") {
            element.type = SVGElement::Type::Circle;
            parsed = ParseCircleElement(child, element);
        } else if (tagName == "rect") {
            element.type = SVGElement::Type::Rect;
            parsed = ParseRectElement(child, element);
        }
        // ... å…¶ä»–å…ƒç´ ç±»å‹
        
        // 4. å°†è§£ææˆåŠŸçš„å…ƒç´ æ·»åŠ åˆ°æ–‡æ¡£
        if (parsed) {
            document.elements.push_back(std::move(element));
        }
    }
    
    return true;
}
```

#### æ­¥éª¤3ï¼šè§£æå…·ä½“å…ƒç´ ï¼ˆä»¥Pathä¸ºä¾‹ï¼‰

```cpp
bool SVGParser::ParsePathElement(tinyxml2::XMLElement* element, 
                                  SVGElement& svgElement) {
    // ä½¿ç”¨placement newåˆå§‹åŒ–è”åˆä½“æˆå‘˜
    new (&svgElement.path) SVGPath();
    
    // è§£æåŸºæœ¬å±æ€§
    svgElement.path.id = GetAttribute(element, "id");
    svgElement.path.style = ParseStyle(element);  // è§£ææ ·å¼
    svgElement.path.transform = ParseTransform(GetAttribute(element, "transform"));
    
    // è§£æè·¯å¾„æ•°æ®ï¼ˆdå±æ€§ï¼‰
    std::string pathData = GetAttribute(element, "d");
    if (pathData.empty()) return false;
    
    return ParsePathData(pathData, svgElement.path.commands);
}
```

#### æ­¥éª¤4ï¼šè§£æè·¯å¾„æ•°æ®ï¼ˆPath Dataï¼‰

**è·¯å¾„å‘½ä»¤æ ¼å¼ï¼š** `M 10 20 L 30 40 Q 50 60 70 80 Z`

```cpp
bool SVGParser::ParsePathData(const std::string& pathData, 
                               std::vector<PathCommand>& commands) {
    size_t i = 0;
    
    while (i < pathData.length()) {
        // è·³è¿‡ç©ºç™½å­—ç¬¦
        while (i < pathData.length() && std::isspace(pathData[i])) i++;
        if (i >= pathData.length()) break;
        
        // è¯»å–å‘½ä»¤å­—ç¬¦ï¼ˆM, L, Q, C, Zç­‰ï¼‰
        char cmd = pathData[i++];
        
        PathCommand command;
        command.type = GetCommandType(cmd);
        
        // æ ¹æ®å‘½ä»¤ç±»å‹è§£æå‚æ•°
        switch (command.type) {
            case PathCommand::Type::MoveTo:
                command.points = ParsePoints(pathData, i, 2);  // è§£æ2ä¸ªç‚¹
                break;
            case PathCommand::Type::LineTo:
                command.points = ParsePoints(pathData, i, 2);
                break;
            case PathCommand::Type::QuadraticBezier:
                command.points = ParsePoints(pathData, i, 4);  // æ§åˆ¶ç‚¹+ç»ˆç‚¹
                break;
            case PathCommand::Type::CubicBezier:
                command.points = ParsePoints(pathData, i, 6);  // 2ä¸ªæ§åˆ¶ç‚¹+ç»ˆç‚¹
                break;
            case PathCommand::Type::ClosePath:
                // Zå‘½ä»¤ä¸éœ€è¦å‚æ•°
                break;
        }
        
        commands.push_back(command);
    }
    
    return true;
}
```

#### æ­¥éª¤5ï¼šè§£ææ ·å¼å’Œå±æ€§

```cpp
SVGStyle SVGParser::ParseStyle(tinyxml2::XMLElement* element) {
    SVGStyle style;
    
    // è§£æfillå±æ€§
    std::string fill = GetAttribute(element, "fill", "none");
    if (fill != "none") {
        style.fillColor = ParseColor(fill);
    }
    
    // è§£æstrokeå±æ€§
    std::string stroke = GetAttribute(element, "stroke", "none");
    if (stroke != "none") {
        style.strokeColor = ParseColor(stroke);
    }
    
    // è§£æstroke-width
    std::string strokeWidth = GetAttribute(element, "stroke-width", "1");
    style.strokeWidth = ParseLength(strokeWidth, 1.0f);
    
    return style;
}
```

### 4.3 æ•°æ®ç»“æ„

**æ–‡ä»¶ï¼š** `src/VCX/Labs/svg/SVG.h`

```cpp
// SVGæ–‡æ¡£ç»“æ„
struct SVGDocument {
    float width, height;
    std::string viewBox;
    std::vector<SVGElement> elements;
};

// SVGå…ƒç´ ç»“æ„ï¼ˆä½¿ç”¨è”åˆä½“èŠ‚çœå†…å­˜ï¼‰
struct SVGElement {
    enum Type { Path, Circle, Ellipse, Rect, Line, Text, Group } type;
    
    std::string id;
    SVGStyle style;
    Transform2D transform;
    std::vector<SVGElement> children;  // ç”¨äºGroup
    
    union {
        SVGPath path;
        SVGCircle circle;
        SVGEllipse ellipse;
        SVGRect rect;
        SVGLine line;
        SVGText text;
    };
};
```

---

## ç¬¬äº”é˜¶æ®µï¼šSVGæ¸²æŸ“

### 5.1 æ¸²æŸ“å…¥å£

**æ–‡ä»¶ï¼š** `src/VCX/Labs/svg/CaseSVGRender.cpp` - `UpdateRender()`

```cpp
void CaseSVGRender::UpdateRender() {
    if (!_fileLoaded) {
        // åˆ›å»ºç©ºç™½å›¾åƒ
        _image = Common::CreatePureImageRGB(_renderWidth, _renderHeight, 
                                           glm::vec3(0.8f, 0.8f, 0.8f));
    } else {
        // æ¸²æŸ“SVGï¼ˆå¸¦é«˜äº®æ˜¾ç¤ºï¼‰
        RenderWithHighlight(_hoveredElementIndex);
    }
    
    // å°†å›¾åƒä¸Šä¼ åˆ°OpenGLçº¹ç†
    _texture.Update(_image);
}
```

**è§¦å‘æ—¶æœºï¼š**
- æ–‡ä»¶åŠ è½½å
- SVGæ–‡æ¡£ä¿®æ”¹å
- ç”¨æˆ·äº¤äº’åï¼ˆé€‰æ‹©ã€æ‹–æ‹½ç­‰ï¼‰

### 5.2 SVGæ–‡æ¡£æ¸²æŸ“

**æ–‡ä»¶ï¼š** `src/VCX/Labs/svg/SVGRenderer.cpp` - `RenderSVG()`

```cpp
Common::ImageRGB SVGRenderer::RenderSVG(const SVGDocument& document,
                                       std::uint32_t width,
                                       std::uint32_t height) {
    // æ­¥éª¤1ï¼šåˆ›å»ºç›®æ ‡å›¾åƒ
    Common::ImageRGB image(width, height);
    
    // æ­¥éª¤2ï¼šå¡«å……èƒŒæ™¯è‰²
    glm::vec3 bgColor(_backgroundColor.r, _backgroundColor.g, _backgroundColor.b);
    for (std::uint32_t y = 0; y < height; ++y) {
        for (std::uint32_t x = 0; x < width; ++x) {
            image.At(x, y) = bgColor;
        }
    }
    
    // æ­¥éª¤3ï¼šéå†æ‰€æœ‰å…ƒç´ å¹¶æ¸²æŸ“
    for (const auto& element : document.elements) {
        RenderElement(element, image);
    }
    
    return image;
}
```

### 5.3 å…ƒç´ æ¸²æŸ“åˆ†å‘

```cpp
void SVGRenderer::RenderElement(const SVGElement& element,
                               Common::ImageRGB& targetImage) {
    switch (element.type) {
        case SVGElement::Type::Path:
            RenderPath(element.path, targetImage);
            break;
        case SVGElement::Type::Circle:
            RenderCircle(element.circle, targetImage);
            break;
        case SVGElement::Type::Rect:
            RenderRect(element.rect, targetImage);
            break;
        case SVGElement::Type::Line:
            RenderLine(element.line, targetImage);
            break;
        case SVGElement::Type::Group:
            // é€’å½’æ¸²æŸ“ç»„å†…å…ƒç´ 
            for (const auto& child : element.children) {
                RenderElement(child, targetImage);
            }
            break;
    }
}
```

### 5.4 å…·ä½“å½¢çŠ¶æ¸²æŸ“ï¼ˆä»¥Pathä¸ºä¾‹ï¼‰

```cpp
void SVGRenderer::RenderPath(const SVGPath& path, Common::ImageRGB& image) {
    // æ­¥éª¤1ï¼šå°†è·¯å¾„å‘½ä»¤è½¬æ¢ä¸ºé¡¶ç‚¹åºåˆ—
    std::vector<Point2D> vertices = path.GetVertices();
    
    // æ­¥éª¤2ï¼šåº”ç”¨å˜æ¢çŸ©é˜µ
    for (auto& vertex : vertices) {
        vertex = path.transform.TransformPoint(vertex);
    }
    
    // æ­¥éª¤3ï¼šç»˜åˆ¶è·¯å¾„
    DrawPath(image, vertices,
             path.style.fillColor.value_or(glm::vec4(0,0,0,0)),
             path.style.strokeColor.value_or(glm::vec4(0,0,0,0)),
             path.style.strokeWidth.value_or(1.0f),
             path.IsClosed());
}
```

### 5.5 åŸºç¡€ç»˜å›¾ç®—æ³•

#### 5.5.1 è·¯å¾„å¡«å……ï¼ˆæ‰«æçº¿ç®—æ³•ï¼‰

```cpp
void SVGRenderer::DrawPath(Common::ImageRGB& image,
                          const std::vector<Point2D>& points,
                          const glm::vec4& fillColor,
                          const glm::vec4& strokeColor,
                          float strokeWidth,
                          bool closed) {
    // 1. å¡«å……ï¼ˆEven-Oddè§„åˆ™ï¼‰
    if (fillColor.a > 0 && points.size() >= 3) {
        // è®¡ç®—YèŒƒå›´
        float minY = points[0].y, maxY = points[0].y;
        for (const auto& p : points) {
            minY = std::min(minY, p.y);
            maxY = std::max(maxY, p.y);
        }
        
        // æ‰«æçº¿å¡«å……
        for (int y = minY; y <= maxY; y++) {
            std::vector<float> intersections;
            float scanY = static_cast<float>(y) + 0.5f;
            
            // è®¡ç®—æ‰«æçº¿ä¸è¾¹çš„äº¤ç‚¹
            for (size_t i = 0; i < points.size(); i++) {
                Point2D p1 = points[i];
                Point2D p2 = points[(i + 1) % points.size()];
                
                if ((p1.y <= scanY && p2.y > scanY) || 
                    (p2.y <= scanY && p1.y > scanY)) {
                    float x = p1.x + (scanY - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
                    intersections.push_back(x);
                }
            }
            
            // æ’åºäº¤ç‚¹ï¼Œæˆå¯¹å¡«å……
            std::sort(intersections.begin(), intersections.end());
            for (size_t i = 0; i + 1 < intersections.size(); i += 2) {
                int xStart = std::ceil(intersections[i]);
                int xEnd = std::floor(intersections[i+1]);
                for (int x = xStart; x <= xEnd; x++) {
                    BlendPixel(image, x, y, fillColor);
                }
            }
        }
    }
    
    // 2. æè¾¹ï¼ˆBresenhamç›´çº¿ç®—æ³•ï¼‰
    if (strokeColor.a > 0) {
        for (size_t i = 0; i < points.size() - 1; i++) {
            DrawLine(image, points[i], points[i+1], strokeColor, strokeWidth);
        }
        if (closed) {
            DrawLine(image, points.back(), points.front(), strokeColor, strokeWidth);
        }
    }
}
```

#### 5.5.2 ç›´çº¿ç»˜åˆ¶ï¼ˆBresenhamç®—æ³•ï¼‰

```cpp
void SVGRenderer::DrawLine(Common::ImageRGB& image,
                          const Point2D& start, const Point2D& end,
                          const glm::vec4& color, float width) {
    // ä½¿ç”¨Bresenhamç®—æ³•ç»˜åˆ¶ç›´çº¿
    int x0 = static_cast<int>(start.x);
    int y0 = static_cast<int>(start.y);
    int x1 = static_cast<int>(end.x);
    int y1 = static_cast<int>(end.y);
    
    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);
    int sx = (x0 < x1) ? 1 : -1;
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx - dy;
    
    while (true) {
        SetPixel(image, x0, y0, color);
        
        if (x0 == x1 && y0 == y1) break;
        
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}
```

#### 5.5.3 åœ†å½¢ç»˜åˆ¶ï¼ˆä¸­ç‚¹åœ†ç®—æ³•ï¼‰

```cpp
void SVGRenderer::DrawCircle(Common::ImageRGB& image,
                            const Point2D& center, float radius,
                            const glm::vec4& color, bool filled) {
    int cx = static_cast<int>(center.x);
    int cy = static_cast<int>(center.y);
    int r = static_cast<int>(radius);
    
    if (filled) {
        // å¡«å……ï¼šæ‰«æçº¿ç®—æ³•
        for (int y = -r; y <= r; y++) {
            int x = static_cast<int>(sqrt(r * r - y * y));
            for (int dx = -x; dx <= x; dx++) {
                SetPixel(image, cx + dx, cy + y, color);
            }
        }
    } else {
        // æè¾¹ï¼šä¸­ç‚¹åœ†ç®—æ³•
        int x = 0, y = r;
        int d = 1 - r;
        
        while (x <= y) {
            SetPixel(image, cx + x, cy + y, color);
            SetPixel(image, cx - x, cy + y, color);
            SetPixel(image, cx + x, cy - y, color);
            SetPixel(image, cx - x, cy - y, color);
            SetPixel(image, cx + y, cy + x, color);
            SetPixel(image, cx - y, cy + x, color);
            SetPixel(image, cx + y, cy - x, color);
            SetPixel(image, cx - y, cy - x, color);
            
            if (d < 0) {
                d += 2 * x + 3;
            } else {
                d += 2 * (x - y) + 5;
                y--;
            }
            x++;
        }
    }
}
```

### 5.6 åƒç´ æ··åˆ

```cpp
void SVGRenderer::BlendPixel(Common::ImageRGB& image,
                            int x, int y, const glm::vec4& color) {
    if (x < 0 || x >= image.GetSizeX() || y < 0 || y >= image.GetSizeY()) {
        return;
    }
    
    glm::vec3& pixel = image.At(x, y);
    
    // Alphaæ··åˆ
    float alpha = color.a;
    pixel = pixel * (1.0f - alpha) + glm::vec3(color.r, color.g, color.b) * alpha;
}
```

### 5.7 çº¹ç†ä¸Šä¼ ä¸æ˜¾ç¤º

```cpp
// åœ¨CaseSVGRender::UpdateRender()ä¸­
_texture.Update(_image);  // å°†CPUå›¾åƒæ•°æ®ä¸Šä¼ åˆ°GPUçº¹ç†

// åœ¨CaseSVGRender::OnRender()ä¸­
return Common::CaseRenderResult {
    .Fixed     = true,
    .Image     = _texture,           // OpenGLçº¹ç†
    .ImageSize = { _renderWidth, _renderHeight },
};
```

**UIç³»ç»Ÿä¼šå°†çº¹ç†æ˜¾ç¤ºåœ¨ä¸»çª—å£ä¸­ã€‚**

---

## å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¨‹åºå¯åŠ¨                                                     â”‚
â”‚  main() â†’ RunApp<Labs::SVG::App>                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  çª—å£åˆå§‹åŒ–                                                   â”‚
â”‚  RunApp_Init()                                               â”‚
â”‚  â”œâ”€> GLFWåˆå§‹åŒ–                                              â”‚
â”‚  â”œâ”€> OpenGLä¸Šä¸‹æ–‡åˆ›å»º                                        â”‚
â”‚  â””â”€> ImGuiåˆå§‹åŒ–                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¸»å¾ªç¯å¯åŠ¨                                                   â”‚
â”‚  while (!glfwWindowShouldClose) {                            â”‚
â”‚      RunApp_Frame(app)                                       â”‚
â”‚  }                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ¯å¸§æ‰§è¡Œ                                                     â”‚
â”‚  App::OnFrame()                                              â”‚
â”‚  â””â”€> UI::Setup()                                             â”‚
â”‚      â”œâ”€> åˆ›å»ºä¾§è¾¹æ                                           â”‚
â”‚      â”œâ”€> CaseSVGRender::OnSetupPropsUI()                    â”‚
â”‚      â”‚   â”œâ”€> ä»£ç ç¼–è¾‘å™¨                                       â”‚
â”‚      â”‚   â”œâ”€> å±æ€§é¢æ¿                                        â”‚
â”‚      â”‚   â”œâ”€> å›¾å±‚åˆ—è¡¨                                        â”‚
â”‚      â”‚   â””â”€> è®¾ç½®é¢æ¿                                        â”‚
â”‚      â”œâ”€> CaseSVGRender::OnRender()                           â”‚
â”‚      â”‚   â””â”€> UpdateRender()                                 â”‚
â”‚      â””â”€> CaseSVGRender::OnProcessInput()                    â”‚
â”‚          â””â”€> å¤„ç†é¼ æ ‡/é”®ç›˜è¾“å…¥                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚          â”‚          â”‚
        â–¼          â–¼          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ–‡ä»¶è¯»å–     â”‚ â”‚  æ–‡ä»¶è§£æ     â”‚ â”‚  æ¸²æŸ“æ˜¾ç¤º     â”‚
â”‚              â”‚ â”‚              â”‚ â”‚              â”‚
â”‚ LoadSVGFile()â”‚ â”‚ ParseFile()  â”‚ â”‚ RenderSVG()  â”‚
â”‚              â”‚ â”‚              â”‚ â”‚              â”‚
â”‚ 1. è¯»å–æ–‡ä»¶   â”‚ â”‚ 1. XMLè§£æ   â”‚ â”‚ 1. åˆ›å»ºå›¾åƒ   â”‚
â”‚ 2. ä¿å­˜æ–‡æœ¬   â”‚ â”‚ 2. è§£æå…ƒç´   â”‚ â”‚ 2. å¡«å……èƒŒæ™¯   â”‚
â”‚ 3. è°ƒç”¨è§£æå™¨ â”‚ â”‚ 3. è§£ææ ·å¼  â”‚ â”‚ 3. æ¸²æŸ“å…ƒç´    â”‚
â”‚              â”‚ â”‚ 4. è§£æè·¯å¾„  â”‚ â”‚ 4. ä¸Šä¼ çº¹ç†   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚               â”‚                â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  OpenGLçº¹ç†æ˜¾ç¤º  â”‚
            â”‚  åœ¨ImGuiçª—å£ä¸­   â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å…³é”®æ•°æ®ç»“æ„æ€»ç»“

### SVGæ–‡æ¡£ç»“æ„
- `SVGDocument`: åŒ…å«å®½åº¦ã€é«˜åº¦ã€viewBoxå’Œå…ƒç´ åˆ—è¡¨
- `SVGElement`: ä½¿ç”¨è”åˆä½“å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ æ•°æ®
- `SVGStyle`: åŒ…å«å¡«å……è‰²ã€æè¾¹è‰²ã€æè¾¹å®½åº¦ç­‰æ ·å¼ä¿¡æ¯
- `Transform2D`: 2Då˜æ¢çŸ©é˜µ

### æ¸²æŸ“ç›¸å…³
- `Common::ImageRGB`: CPUç«¯çš„RGBå›¾åƒç¼“å†²åŒº
- `Engine::GL::UniqueTexture2D`: GPUç«¯çš„OpenGLçº¹ç†
- `PathCommand`: è·¯å¾„å‘½ä»¤ï¼ˆMoveTo, LineTo, Bezierç­‰ï¼‰

---

## æ€»ç»“

æ•´ä¸ªé¡¹ç›®çš„æµç¨‹å¯ä»¥æ¦‚æ‹¬ä¸ºï¼š

1. **åˆå§‹åŒ–é˜¶æ®µ**ï¼šåˆ›å»ºçª—å£ã€OpenGLä¸Šä¸‹æ–‡ã€ImGuiç³»ç»Ÿ
2. **UIæ„å»ºé˜¶æ®µ**ï¼šåˆ›å»ºä¾§è¾¹æ ã€ä¸»çª—å£ã€å„ç§é¢æ¿
3. **æ–‡ä»¶å¤„ç†é˜¶æ®µ**ï¼šè¯»å–SVGæ–‡ä»¶ â†’ XMLè§£æ â†’ è½¬æ¢ä¸ºå†…éƒ¨æ•°æ®ç»“æ„
4. **æ¸²æŸ“é˜¶æ®µ**ï¼šéå†å…ƒç´  â†’ åº”ç”¨å˜æ¢ â†’ è°ƒç”¨ç»˜å›¾ç®—æ³• â†’ ç”Ÿæˆåƒç´ å›¾åƒ
5. **æ˜¾ç¤ºé˜¶æ®µ**ï¼šå°†å›¾åƒä¸Šä¼ åˆ°GPUçº¹ç† â†’ åœ¨ImGuiçª—å£ä¸­æ˜¾ç¤º
6. **äº¤äº’é˜¶æ®µ**ï¼šå¤„ç†ç”¨æˆ·è¾“å…¥ â†’ æ›´æ–°SVGæ–‡æ¡£ â†’ é‡æ–°æ¸²æŸ“

æ•´ä¸ªç³»ç»Ÿé‡‡ç”¨**äº‹ä»¶é©±åŠ¨**çš„æ¶æ„ï¼Œç”¨æˆ·æ“ä½œè§¦å‘ç›¸åº”çš„æ›´æ–°å’Œé‡æ¸²æŸ“ï¼Œå®ç°äº†å®æ—¶çš„SVGç¼–è¾‘å’Œé¢„è§ˆåŠŸèƒ½ã€‚


